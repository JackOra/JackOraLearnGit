#### [接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

> 给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)
>
> ```
> 输入: [0,1,0,2,1,0,1,3,2,1,2,1]
> 输出: 6
> ```

##### 法一：数学方法

###### 从左遍历是s1 + 从右边遍历s2， s1 + s2  - 矩形面积 = 重复面积=柱子面积  + 积水面积

```python
class Solution:
    def trap(self, height: List[int]) -> int:

        n = len(height)
        max1, max2 = 0, 0
        s1, s2 =0, 0
        for i in range(len(height)):
            if height[i] >= max1:
                max1 = height[i]
            if height[n-i-1] > max2:
                max2 = height[n-i-1]
            s1 += max1
            s2 += max2
        return s1 + s2 - max1 * len(height) - sum(height)
```

##### 栈

- 通过栈来保存每一堵墙

- 通过current来访问每一个堵墙

  - 当current高度小于等于栈顶高度，则直接入栈，current后移一位
  - 当current高度大于栈顶高度的时候，出栈，并且计算积水面积，计算完继续判断current和栈顶高度比较，如果不大于或者栈为空，则直接入栈

  

```java
class Solution {
    public int trap(int[] height) {
        int sum = 0;
        Stack<Integer> stack = new Stack<>();
        int current = 0;
        while (current < height.length){
            while (!stack.isEmpty() && height[current] > height[stack.peek()]){
                int h = height[stack.peek()];
                stack.pop();
                if (stack.isEmpty()){
                    break;
                }
                int w = current - stack.peek() - 1;
                int min = Math.min(height[current], height[stack.peek()]);
                sum += (min - h) * w;
            }
            stack.push(current);
            current++;
        }
        return sum;
    }
}
```

